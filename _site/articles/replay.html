<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Full Game Replay | Netick Networking Engine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Full Game Replay | Netick Networking Engine ">
      <meta name="description" content="Netick is a high-performance networking solution for Unity.">
      
      <meta property="og:title" content="Full Game Replay | Netick Networking Engine ">
      <meta property="og:description" content="Netick is a high-performance networking solution for Unity.">
      <meta property="og:type" content="article">
      <meta property="og:url" content="https://netick.net/articles/replay.html">
      <meta property="og:image" content="https://netick.net/imgs/netick_card.png">

      <meta name="twitter:card" content="summary_large_image">
      <meta name="twitter:title" content="Full Game Replay | Netick Networking Engine ">
      <meta name="twitter:description" content="Netick is a high-performance networking solution for Unity.">
      <meta name="twitter:image" content="https://netick.net/imgs/netick_card.png">

      <link rel="canonical" href="https://netick.net/articles/replay.html">
      
      
      <link rel="icon" href="../images/logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../pdf/toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>

  <script>
    // Navbar scroll effect - adds glossy effect when scrolled
    window.addEventListener('scroll', function() {
      const navbar = document.querySelector('.navbar');
      if (navbar) {
        if (window.scrollY > 50) {
          navbar.classList.add('scrolled');
        } else {
          navbar.classList.remove('scrolled');
        }
      }
    });
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Netick Docs">
            Netick Docs
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="full-game-replay">Full Game Replay</h1>

<hr>
<p>The replay system in Netick allows for recording the <em>entire networked state</em> of a game (including all network objects, RPCs, and scene state) on the server. This data can later be used to replay the full game exactly as it happened.</p>
<p>Netick employs highly efficient compression for these recordings. Therefore, replay files are smaller than those found in major commercial titles with state-based replay systems (such as World of Tanks, Counter-Strike, Overwatch, Fortnite, Dota, Rocket League, and Valorant).</p>
<p>Unlike replay systems in games such as Valorant, which store raw network packets and must process every packet sequentially to reach a target frame (making seeking very slow), Netick records snapshots of the full game state.
This approach is conceptually similar to video compression formats, allowing for instant seeking without needing to apply all previous data.</p>
<h3 id="use-cases">Use Cases</h3>
<ul>
<li>Game Analysis: Let players review full matches and analyze them.</li>
<li>Cheat Review: Let admins investigate potential cheating (e.g., wallhacks, aimbots) by replaying suspicious matches.</li>
<li>Debugging: Simulate late-joins or extended packet loss by skipping through the replay timeline.</li>
<li>Videos: Both developers and players can screen record replays to create videos for various purposes. Unlike regular screen recording alone, replays are actual replays of the game, so it's possible to change the camera location and capture things not possible with regular screen recording alone.</li>
</ul>
<h3 id="overview">Overview</h3>
<p>Recording in Netick’s replay system is <strong>entirely server-side</strong>.
To replay a recording, Netick must be started in a special mode called <strong>Replay Client</strong>.</p>
<p>A Replay Client behaves like a normal client, with a few key differences:</p>
<ul>
<li>It’s not connected to a live server, the replay snapshots are applied directly instead of receiving live network packets.</li>
<li>The prediction loop is disabled.</li>
<li>The local player id <code>Sandbox.LocalPlayer</code> is fixed to <code>NetworkPlayerId.ReplayPlayer</code>. This ensures RPCs sent to that id during recording will still exist when replaying.</li>
<li>The local player does not appear in <code>Sandbox.Players</code>, as it’s only a dummy player that was never in the game when it was recorded.</li>
</ul>
<p>Replays recorded on older versions of the game are incompatible and can't be replayed on newer versions. This limitation exists on all replay systems. While it's rarely done, one way to deal with this is to keep older builds of the game and use them to play older replays. However, Netick does not handle any of this and is up to the developer if needed.</p>
<hr>
<h2 id="replay-safety">Replay-Safety</h2>
<p>In most cases, achieving replay safety (making a project fully compatible with Netick’s Replay System) is straightforward.
During replay playback, the game logic operates on recorded snapshots rather than live network packets. To handle any special cases, you can check whether the current session is a replay using:</p>
<pre><code class="lang-cs">if (Sandbox.IsReplay)
{
    // Logic specific to replay mode
}
</code></pre>
<p>This allows you to adjust or skip code that should not run during replay.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Viewing the game from the perspective of different players is not handled automatically. Developers must implement support for this functionality as needed.</p>
</div>
<h2 id="replay-api">Replay API</h2>
<p>The Replay System consists of two primary components:</p>
<ul>
<li><strong>Recording API</strong> (server-side only)</li>
<li><strong>Playback API</strong> (for replay clients)</li>
</ul>
<hr>
<h3 id="recording">Recording</h3>
<p>Recording is only supported on the <strong>server</strong>.</p>
<p><strong>Start recording:</strong></p>
<pre><code class="lang-csharp">Sandbox.StartReplayRecording(replayPath);
</code></pre>
<p><strong>Stop recording:</strong></p>
<pre><code class="lang-csharp">Sandbox.StopReplayRecording();
</code></pre>
<p>If no path is provided, Netick automatically records to a file (named with the current date and time) inside:</p>
<pre><code class="lang-csharp">Path.Combine(Application.persistentDataPath, &quot;replays&quot;, Network.GameVersion.ToString());
</code></pre>
<p><strong>Example (Windows path):</strong></p>
<pre><code>C:\Users\&lt;username&gt;\AppData\LocalLow\&lt;CompanyName&gt;\&lt;ProjectName&gt;\replays\&lt;gameVersionHash&gt;\&lt;replayFileName&gt;
</code></pre>
<h4 id="replay-metadata">Replay Metadata</h4>
<p>Including metadata in a replay file is often useful for capturing additional game-specific information, such as round start and end times, special events, or custom markers.</p>
<p>Netick provides a simple API for this purpose:</p>
<pre><code class="lang-cs">Sandbox.Replay.Record.SetReplayMetadata(metaDataByteArray);
</code></pre>
<p>When getting this data, you can use <code>Sandbox.Replay.Record.FrameIndex</code> to determine the current replay frame being recorded. This allows you to associate metadata precisely with a specific moment in the replay timeline.</p>
<hr>
<h3 id="playback">Playback</h3>
<h4 id="starting-a-replay">Starting a Replay</h4>
<p>To play a replay file, start Netick in <strong>Replay Client</strong> mode:</p>
<pre><code class="lang-csharp">var sandbox = Netick.Unity.Network.StartAsReplayClient();
</code></pre>
<p>Then begin playback:</p>
<pre><code class="lang-csharp">sandbox.StartReplayPlayback(replayPath);
</code></pre>
<p>If no path is specified (<code>sandbox.StartReplayPlayback()</code>), Netick automatically loads the <strong>most recent replay file</strong> from:</p>
<pre><code>C:\Users\&lt;username&gt;\AppData\LocalLow\&lt;CompanyName&gt;\&lt;ProjectName&gt;\replays\&lt;gameVersionHash&gt;\
</code></pre>
<h4 id="replay-metadata-1">Replay Metadata</h4>
<p>To get the replay metadata during playback:</p>
<pre><code class="lang-csharp">Sandbox.Replay.Playback.TryGetReplayMetadata(out byte[] data);
</code></pre>
<h4 id="validating-replay-files">Validating Replay Files</h4>
<p>Always check replay file info before starting playback:</p>
<pre><code class="lang-csharp">var replayFileInfo   = await FileReplayTransport.GetReplayFileInfoAsync(path);
var replayFileStatus = replayFileInfo.Status;
</code></pre>
<p>This asynchronous method returns a <code>ReplayFileInfo</code> struct, with a <code>Status</code> variable indicating the status of the replay file.</p>
<pre><code class="lang-csharp">public enum ReplayFileStatus
{
    Ok,
    NotFound,
    Invalid,
    VersionMismatch,
}
</code></pre>
<p>You can use this result to decide how to handle missing, corrupted, or incompatible replay files.</p>
<h4 id="version-compatibility">Version Compatibility</h4>
<p>Netick prevents replaying files recorded with mismatched versions.
Replay validation checks the value of <code> Netick.Unity.Network.GameVersion</code>, which is a hash of:</p>
<ul>
<li><strong>Netick version:</strong> <code> Netick.Unity.Network.Version</code></li>
<li><strong>Game version:</strong> <code>Application.version</code> (configured in <em>Project Settings → Player</em>)</li>
</ul>
<p>If either version changes, existing replay files become incompatible.</p>
<hr>
<h3 id="playback-control">Playback Control</h3>
<p>Once playback begins with <code>Sandbox.StartReplayPlayback(replayPath)</code>, you can control playback via the <strong>Playback API</strong>:</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>API</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seek / Skip (by time)</td>
<td><code>Sandbox.Replay.Playback.SeekToTime(time);</code></td>
</tr>
<tr>
<td>Seek / Skip (by frame)</td>
<td><code>Sandbox.Replay.Playback.SeekToFrame(frame);</code></td>
</tr>
<tr>
<td>Get total duration (seconds)</td>
<td><code>Sandbox.Replay.Playback.Duration;</code></td>
</tr>
<tr>
<td>Get total frame count</td>
<td><code>Sandbox.Replay.Playback.FrameCount;</code></td>
</tr>
<tr>
<td>Set / Get time scale</td>
<td><code>Time.timeScale;</code></td>
</tr>
</tbody>
</table>
<p>Slowing down or speeding up the playback is done by simply increasing/decreasing <code>Time.timeScale</code>. Pausing the playback is accomplished by setting <code>Time.timeScale</code> to <code>0</code>.</p>
<p><code>Sandbox.Replay.Playback.OnSeeked</code> event can be used for clean up or similar actions when seeking.</p>
<h4 id="replay-timeline-ui">Replay Timeline UI</h4>
<p>Netick includes a built-in helper script, <code>ReplayTimeline.cs</code>, that provides a timeline UI for replay playback.</p>
<div class="NOTE">
<h5>Note</h5>
<p>In the replay system, the term “Frame” refers to snapshots of the game, not rendering frames. These replay frames correspond to ticks in the simulation, but are labeled as frames within the context of replays.</p>
</div>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2022-2025 Karrar Rahim. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
