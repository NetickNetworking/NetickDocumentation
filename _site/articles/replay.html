<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Full Game Replay | Netick Networking Engine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Full Game Replay | Netick Networking Engine ">
      
      <link rel="icon" href="../images/logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Netick Docs">
            Netick Docs
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="full-game-replay">Full Game Replay</h1>

<h2 id="file-replay-backend">File Replay Backend</h2>
<p>The replay system in Netick allows for recording the <em>entire networked state</em> of a game (including all network objects, RPCs, and scene state) directly on the server. This data can later be used to replay the full game exactly as it happened.</p>
<p>Unlike replay systems in games such as Counter-Strike, which store raw network packets and must process every packet sequentially to reach a target frame (making seeking very slow), Netick records snapshots of the full game state.
This approach is conceptually similar to video compression formats, allowing for instant seeking without needing to apply all previous data.</p>
<h3 id="use-cases">Use Cases</h3>
<ul>
<li>Player improvement: Let players review full matches to learn from mistakes or study better players.</li>
<li>Cheat review: Let admins investigate potential cheating (e.g., wallhacks, aimbots) by replaying suspicious matches.</li>
<li>Debugging: Simulate late-joins or extended packet loss by skipping through the replay timeline.</li>
</ul>
<h3 id="overview">Overview</h3>
<p>Recording in Netick’s replay system is <strong>entirely server-side</strong>.
To replay a recording, Netick must be started in a special mode called <strong>Replay Client</strong>.</p>
<p>A Replay Client behaves like a normal client, with a few key differences:</p>
<ul>
<li>It’s not connected to a live server, the replay snapshots are applied directly instead of receiving live network packets.</li>
<li>The prediction loop is disabled.</li>
<li>The local player id <code>Sandbox.LocalPlayer</code> is fixed to <code>NetworkPlayerId.ReplayPlayer</code>. This ensures RPCs sent to that id during recording will still exist when replaying.</li>
<li>The local player does not appear in <code>Sandbox.Players</code>, as it’s only a dummy player that was never in the game when it was recorded.</li>
</ul>
<p>Replays recorded on older versions of the game are incompatible and can't be replayed on newer versions. This limitation exists on all replay systems. While it's rarely done, one way to deal with this is to keep older builds of the game and use them to play older replays. However, Netick does not handle any of this and is up to the developer if needed.</p>
<hr>
<h2 id="replay-safety">Replay-Safety</h2>
<p>In most cases, achieving replay safety (making a project fully compatible with Netick’s Replay System) is straightforward</p>
<p>During replay playback, the game logic operates on recorded snapshots rather than live network packets. To handle any special cases, you can check whether the current session is a replay using:</p>
<pre><code class="lang-cs">if (Sandbox.IsReplaying)
{
    // Logic specific to replay mode
}
</code></pre>
<p>This allows you to adjust or skip code that should not run during replay.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Viewing the game from the perspective of different players is not handled automatically. Developers must implement support for this functionality as needed.</p>
</div>
<h2 id="replay-api">Replay API</h2>
<p>The Replay System consists of two primary components:</p>
<ul>
<li><strong>Recording API</strong> (server-side only)</li>
<li><strong>Playback API</strong> (for replay clients)</li>
</ul>
<hr>
<h3 id="recording">Recording</h3>
<p>Recording is only supported on the <strong>server</strong>.</p>
<p><strong>Start recording:</strong></p>
<pre><code class="lang-csharp">Sandbox.StartRecording(replayPath);
</code></pre>
<p><strong>Stop recording:</strong></p>
<pre><code class="lang-csharp">Sandbox.StopRecording();
</code></pre>
<p>If no path is provided, Netick automatically records to:</p>
<pre><code class="lang-csharp">Path.Combine(Application.persistentDataPath, &quot;replays&quot;, Network.GameVersion.ToString());
</code></pre>
<p><strong>Example (Windows path):</strong></p>
<pre><code>C:\Users\&lt;username&gt;\AppData\LocalLow\&lt;CompanyName&gt;\&lt;ProjectName&gt;\replays\&lt;gameVersionHash&gt;\&lt;replayFileName&gt;
</code></pre>
<h3 id="replay-metadata">Replay Metadata</h3>
<p>Including metadata in a replay file is often useful for capturing additional game-specific information, such as round start and end times, special events, or custom markers.</p>
<p>Netick provides a simple API for this purpose:</p>
<pre><code class="lang-cs">Sandbox.Replay.Record.SetReplayMetadata(metaDataByteArray);
</code></pre>
<p>The data here can be in a JSON format, for instance. When collecting this metadata, you can use <code>Sandbox.Replay.Record.FrameIndex</code> to determine the current replay frame being recorded. This allows you to associate metadata precisely with a specific moment in the replay timeline.</p>
<hr>
<h3 id="playback">Playback</h3>
<h4 id="starting-a-replay">Starting a Replay</h4>
<p>To play a replay file, start Netick in <strong>Replay Client</strong> mode:</p>
<pre><code class="lang-csharp">var sandbox = Netick.Unity.Network.StartAsReplayClient();
</code></pre>
<p>Then begin playback:</p>
<pre><code class="lang-csharp">sandbox.StartPlayback(replayPath);
</code></pre>
<p>If no path is specified (<code>sandbox.StartPlayback()</code>), Netick automatically loads the <strong>most recent replay file</strong> from:</p>
<pre><code>C:\Users\&lt;username&gt;\AppData\LocalLow\MyStudio\MyGame\replays\&lt;gameVersionHash&gt;\
</code></pre>
<h4 id="replay-metadata-1">Replay Metadata</h4>
<p>To get the replay metadata during playback:</p>
<pre><code class="lang-csharp">Sandbox.Replay.Playback.TryGetReplayMetadata(out byte[] data);
</code></pre>
<h4 id="validating-replay-files">Validating Replay Files</h4>
<p>Always check replay validity before starting playback:</p>
<pre><code class="lang-csharp">var replayValidationResult = await FileReplayBackend.ValidateReplayFileAsync(path);
</code></pre>
<p>This asynchronous method returns a <code>ReplayValidationResult</code> enum:</p>
<pre><code class="lang-csharp">public enum ReplayValidationResult
{
    Ok,
    NotFound,
    Invalid,
    VersionMismatch,
}
</code></pre>
<p>You can use this result to decide how to handle missing, corrupted, or incompatible replay files.</p>
<h4 id="version-compatibility">Version Compatibility</h4>
<p>Netick prevents replaying files recorded with mismatched versions.
Replay validation checks the value of <code> Netick.Unity.Network.GameVersion</code>, which is a hash of:</p>
<ul>
<li><strong>Netick version:</strong> <code> Netick.Unity.Network.Version</code></li>
<li><strong>Game version:</strong> <code>Application.version</code> (configured in <em>Project Settings → Player</em>)</li>
</ul>
<p>If either version changes, existing replay files become incompatible.</p>
<hr>
<h3 id="playback-control">Playback Control</h3>
<p>Once playback begins with <code>Sandbox.StartPlayback(replayPath)</code>, you can control the timeline via the <strong>Playback API</strong>:</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seek / Skip (by time)</td>
<td><code>Sandbox.Replay.Playback.SeekToTime(time);</code></td>
</tr>
<tr>
<td>Seek / Skip (by frame)</td>
<td><code>Sandbox.Replay.Playback.SeekToFrame(frame);</code></td>
</tr>
<tr>
<td>Get total duration (seconds)</td>
<td><code>Sandbox.Replay.Playback.Duration;</code></td>
</tr>
<tr>
<td>Get total frame count</td>
<td><code>Sandbox.Replay.Playback.TotalFrames;</code></td>
</tr>
</tbody>
</table>
<p>Slowing down or speeding up the playback is done by simply increasing/decreasing <code>Time.timeScale</code>. Pausing the playback is accomplished by setting <code>Time.timeScale</code> to <code>0</code>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>In the replay system, the term “Frame” refers to snapshots of the game, not rendering frames. These replay frames correspond to ticks in the simulation, but are labeled as frames within the context of replays.</p>
</div>
<hr>
<h2 id="replay-compression">Replay Compression</h2>
<p>By default, Netick applies delta compression to replay snapshots. This allows for instant recording and playback with minimal processing overhead.</p>
<p>Despite that, developers can apply additional compression using generic algorithms (e.g., zlib, LZ4, Brotli). This can significantly reduce the size of replay files. However, it adds processing delay before being able to start playback when decompressing the replay file, and after recording is finished when compressing the file. Because delta compression alone already does a reasonable job at compressing the data, Netick does not internally do generic compression on the replay file. However, if needed, doing it is straightforward.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2022-2025 Karrar Rahim. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
