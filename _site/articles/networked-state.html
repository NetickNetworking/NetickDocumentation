<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Networked State | Netick Networking Engine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Networked State | Netick Networking Engine ">
      
      <link rel="icon" href="../images/logo.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/logo.png" alt="Netick Docs | v2">
            Netick Docs | v2
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="networked-state">Networked State</h1>

<p>Networked state is the data of the game that you want to replicate to players. In Netick, networked state is delta compressed, therefore only changes are replicated. If a field of a struct changes, only that field is replicated. If a counter increases, only the delta to the previous value is replicated. If your counter was at 32534536, and now it is at 32534537, it will be replicated as a delta of one. It applies to vectors and quaternions too. Thus, using as little bandwidth as possible.</p>
<p>Every networked property/array can be predicted and interpolated too. Allowing you to create complex networked systems easily.</p>
<h2 id="network-properties">Network Properties</h2>
<p>A network property is a C# property which is replicated across the network. For a property to be networked, the attribute [<a class="xref" href="../api/Netick.Networked.html">Networked</a>] must be added to it.</p>
<p>Examples of networked properties:</p>
<pre><code class="lang-csharp">[Networked]
public int              Health   {get; set;}

[Networked]
public float            Speed    {get; set;}

[Networked]
public Vector3          Velocity {get; set;}

[Networked]
public int              Ammo     {get; set;}

[Networked]
public NetworkBool      IsAlive  {get; set;}

[Networked]
public NetworkString32  Name     {get; set;}
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Reference types are not networkable.</p>
</div>
<h2 id="network-arrays">Network Arrays</h2>
<p>Network arrays are just like regular C# arrays, but their syntax is a bit different. They are defined using the <a class="xref" href="../api/Netick.NetworkArray-1.html">NetworkArray&lt;T&gt;</a> generic class.</p>
<p>Example of a network array:</p>
<pre><code class="lang-csharp">[Networked(size: 32)]
public readonly NetworkArray&lt;int&gt; IntArrayExample = new NetworkArray&lt;int&gt;(32) { 55, 66, 77 };
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p><code>size</code> of [<a class="xref" href="../api/Netick.Networked.html">Networked</a>(size: 32)] must be the same as the value that is passed to the array constructor <code>new NetworkArray&lt;int&gt;(32)</code></p>
</div>
<h2 id="network-array-structs">Network Array Structs</h2>
<p>Netick 2 introduces a new type of network array, network arrays that are completely value types - Network Array Structs. These are fixed-size struct arrays available only in 4 fixed sizes: 8, 16, 32, and 64.</p>
<p>Network Array Structs are pretty useful since they can used as members of another struct, or even nested inside other arrays. In addition, they can be sent as RPC parameters.</p>
<pre><code class="lang-csharp">// Network Struct Array Examples

[Networked]
public NetworkArrayStruct8&lt;int&gt;                      IntFixedArray { get; set; } = new int[] {1 , 4 ,5}.ToNetworkStructArray8();

[Networked]
public NetworkArrayStruct8&lt;NetworkArrayStruct8&lt;int&gt;&gt; ArrayOfArrays { get; set; };
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Network Array Structs are treated as if they were simple struct types like <code>int</code> or <code>float</code>, so they must be defined as a property not as a field (like normal NetworkArray that is non-fixed size).</p>
</div>
<h3 id="changing-elements-of-network-array-struct">Changing elements of Network Array Struct</h3>
<p>Because Network Array Structs are structs, the whole array will be replaced even when you change a single element. To avoid bugs, this should be how you change array elements:</p>
<pre><code class="lang-csharp">IntFixedArray = IntFixedArray.Set(index, value);
// as you can see, we are reassigning the property with the new changed array which has the change.
</code></pre>
<h2 id="network-collections">Network Collections</h2>
<p>In addition to NetworkArray, Netick also has alternatives to C# collections that are fully synced, predicted, and interpolated.</p>
<ul>
<li>NetworkLinkedList<t></t></li>
<li>NetworkStack<t></t></li>
<li>NetworkQueue<t></t></li>
</ul>
<h3 id="usage-examples">Usage examples:</h3>
<pre><code class="lang-csharp">[Networked(size: 5)]
public readonly NetworkLinkedList&lt;int&gt;  MyNetworkedList  = new NetworkLinkedList&lt;int&gt;(5);

[Networked(size: 5)]
public readonly NetworkQueue&lt;int&gt;       MyNetworkedQueue = new NetworkQueue&lt;int&gt;(5);

[Networked(size: 5)]
public readonly NetworkStack&lt;int&gt;       MyNetworkedStack = new NetworkStack&lt;int&gt;(5);
</code></pre>
<p>Removing and adding elements is the same as with C# collections.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>size</code> that you pass to [Networked] and the constructor represents the fixed capacity of the collection. The collections don't support resizing as all network state sizes are set in compile time.</p>
</div>
<h2 id="network-structs">Network Structs</h2>
<p>Netick can synchronize any struct that does not contain class-based arrays or references. Which includes all C# primitive types and Unity/Godot/Flax primitive types.</p>
<p>Example:</p>
<pre><code class="lang-csharp">public struct MyNestedStruct
{
    public int                      Int;
    public NetworkBool              Bool;
    public float                    Float;
    public double                   Double;
    public Vector3                  Position;
    public Quaternion               Rotation;
    public Color                    Color;
    public NetworkString8           Name;
}

public struct MyStruct
{
    public MyNestedStruct           MyNestedStruct;
    public NetworkArrayStruct8&lt;int&gt; StructArray;
    public int                      Int;
    public NetworkBool              Bool;
    public float                    Float;
    public double                   Double;
}

[Networked]
public MyStruct MyStructProperty {get; set;}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p><code>string</code> is not supported as a type that can be used inside a struct. Use <code>NetworkString</code> instead.</p>
</div>
<h2 id="replication-relevancy">Replication Relevancy</h2>
<p>You can choose to replicate a property only to the Input Source client of the object. This is done using the optional parameter <code>relevancy</code> of [<a class="xref" href="../api/Netick.Networked.html">Networked</a>].</p>
<p>Example:</p>
<pre><code class="lang-csharp">[Networked(relevancy: Relevancy.InputSource)] 
public int              Ammo     {get; set;}
</code></pre>
<h2 id="state-synchronization">State Synchronization</h2>
<p>Updates to the network state are atomic, it's not possible for a property to update in the client without other changed properties to update alongside it. If you change two properties in the server at the same time, you are ensured to have both replicate together in the client. This makes it so that you don't have to worry about packet loss and possible race conditions that might occur due to some properties updates arriving while others not arriving. This simplifies how you program your game as you never have to worry about such things happening.</p>
<p>This also means that when you create an object in the server, assign some initial values to some network properties, when this object is created in the client, inside <code>NetworkStart</code> of that object you will have full initial state that you assigned in the server.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2022-2024 Karrar Rahim. All Rights Reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
